# 高性能网站建设指南

## 规则1——减少HTTP请求

<font size=5><b>图片地图</b></font>

<b><i>介绍</i></b>

> 图片地图允许你在一个图片上关联多个URL，目标URL的选择取决于用户点击了图片上的哪个位置。图片地图有两种类型，<b>服务器端图片地图</b>将所有点击提交到同一个目标URL，向其传递x,y坐标，web应用程序将该x,y坐标映射为适当的操作。<b>客户端图片地图</b>通过HTML的MAP标签将用户的点击映射到操作。

<b><i>缺点</i></b>

- 难以用手工的方式定义区域坐标
- 只能定义矩形
- 通过DHTML创建的图片地图不能再Internet Explorer中工作。

<font size=5><b>CSS Sprites</b></font>

<b><i>介绍</i></b>

> 和图片地图一样，css Sprites也可以合并图片，减少HTTP请求，但更灵活。使用css的background-position属性，可以将HTML元素放置到背景图片中期望的位置上。

<font size=7><b>内联图片</b></font>

<b><i>介绍</i></b>

> 通过使用data:URL模式可以在web页面中包含图片但无需任何额外的HTTP请求。格式如下

    data:[<mediatype>][;base64],<data>
    
<b><i>缺点</i></b>
- 不受IE支持
- 数据大小有限制

<font size=7><b>合并脚本和样式</b></font>

<b><i>介绍</i></b>

在生产环境将多个脚本和样式表合并

****

## 规则2——使用内容发布网络

<b><i>介绍</i></b>

> 如果应用程序web服务器离用户更近，则一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器离用户更近，则多个HTTP请求的响应时间将缩短。

内容发布网络（CDN）是一组分布在多个不同地理位置的web服务器，用于更加有效地向用户发布内容。

CDN用于发布静态内容，如图片、脚本、样式表和Flash。

****

## 规则三——添加Expires头

<b>Expires头</b>

Web服务器使用Expires头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。可以将页面中图片样式等设置缓存，浏览器在后续的页面中会使用缓存的图片，将HTTP请求的数量减少。如下：
    
    Expires: Mon, 15 Apr 2024 20:00:00 GMT
    
<b>Max-Age和mod_expires</b>

因为Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步。另外，过期日期需要经常检查并且一旦未来这一天到来了，还需要在服务器配置中提供一个新的日期。

HTTP1.1中Cache-Control使用max-age指令指定组件被缓存多久，它以秒为单位定义一个更新窗。如果从组件被请求开始过去的秒数少于max-age,浏览器就使用缓存的版本，这就避免了额外的HTTP请求。对于不支持HTTP1.1的浏览器你可以同时写两个响应头Expires和max-age,并且Max-age指令会重写Expires头。

如果一个组件没有长久的Expires头，它仍然会存储在浏览器的缓存中。在后续请求浏览器会检查缓存并发现组件已经过期，浏览器为了提高效率会发送一个条件GET请求，如果组件没有改变，只会发送一个很小的头告诉浏览器可以使用其缓存的组件。

****

## 规则四——压缩组件

> Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持：

    Accept-Encoding:gzip, deflate
    
如果web服务器看到请求头中有这个头，就会使用客户端列出来的方法中的一种来压缩响应。web服务器通过响应中的<i>Content-Encoding</i>头来通知客户端

    Content-Encoding: gzip
    
<b>压缩内容</b>

通常压缩HTML文档，脚本和样式表，其实包括XML和JSON在内的任何文本响应都可以被压缩。但图片和PDF不应该压缩，因为他们本来就已经被压缩了，试图对它们进行压缩只会浪费CPU资源，还有可能会增加文件大小。

****

## 规则5——将样式表放在顶部

<b>网页渲染机制</b>

> 解析HTML标签，构建DOM树 >> 解析CSS标签,构建CSSOM树 >> 把DOM和CSSOM组合成渲染树(render tree) >> 在渲染树的基础上进行布局, 计算每个节点的几何结构 >> 把每个节点绘制到屏幕上 (painting)

<b>浏览器出现白屏的原因</b>

<b><i>白屏问题</i></b>

在使用样式表时，页面逐步呈现会被阻止，直到所有的样式表下载完成。所以需要将样式表放在页面顶部HEAD中。
如果把样式放在底部，对于IE浏览器，chrome等（css全部加载后再呈现,有可能等待长），在某些场景下(新窗口打开，刷新等)页面会出现白屏，而不是内容逐步展现。使用 @import 标签，即使 CSS 放入 link, 并且放在头部,也可能出现白屏。

对于图片和CSS, 在加载时会并发加载(如一个域名下同时加载两个文件)。 但在加载 JavaScript 时，会禁用并发，并且阻止其他内容的下载. 所以把 JavaScript 放入页面顶部也会导致白屏现象.

<b><i>FOUC</i></b>

 Flash of Unstyled Content "无样式内容闪烁“：有些浏览器是边渲染边呈现，CSS放置body标签底部，会出现加载html结束后才一次性加载css样式，从而导致页面闪烁。
 
<b>怎么避免出现白屏</b>
 
<b><i>引入位置</i></b>
 
 - css:一般将css放置head里用style包裹，也可以使用link标签引入
 - js:一般放置body标签的尾部
 
<b><i>加入异步</i></b>

没有defer或async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

<b>async</b> : 脚本延迟到文档解析和显示后执行，有顺序   <script async src="script.js"></script>
有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

<b>defer</b>:不保证顺序 <script defer src="script.js"></script>
有defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

****

## 规则6——将脚本放在底部

将脚本放在顶部的影响

- 脚本会阻塞对其后面内容的呈现
- 脚本会阻塞对其后面组件的下载

****

## 规则7——避免CSS表达式

对css表达式的频繁求值使其得以工作，但也导致css表达式的低下性能。

<b>避开该问题</b>

- 一次性表达式
- 使用js中事件处理器

****

## 规则8——使用外部JavaSCript和CSS

> 在第一次加载中内联样式脚本比外部的快，因为外部多了HTTP请求。但是外部javascript和css文件有机会被浏览器缓存起来。而HTML文档通常不会被缓存，这样每次文档下载都会下载内联的样式文档和脚本。

<b>两全其美</b>

> 下面的方式既可以获得内联的优势，同时也能缓存外部文件。

<b><i>加载后执行</i></b>

通过创建对应的DOM元素(script和link)并赋予URL来实现

<b><i>动态内联</i></b>

通过cookies做指示器，让主页服务器知道一个组件是否在浏览器的缓存中。如果cookie不存在就内联JS和css，如果cookie出现了，则有可能外部组件位于浏览器缓存中。

****

## 规则9——减少DNS查找

<b>介绍</b>

> Internet是通过IP地址来查找服务器的，DNS将主机名映射到IP地址上。如果一个服务器被另外一个具有不同IP地址的服务器替代了，DNS允许用户使用同样的主机名来连接到新的服务器。

<b>DNS缓存和TTL</b>

DNS信息会留在操作系统的DNS缓存中，很多浏览器拥有其自己的缓存，和操作系统的缓存相分离。只要浏览器在其缓存中保留了DNS记录，它就不会麻烦操作系统来请求这个记录，否则会向操作系统询问地址。

由于IP地址会变化以及缓存会消耗内存，因此应该周期性地消除缓存中的DNS记录，并通过大量不同的配置检测清除的频率有多高。

<b>影响DNS缓存的因素</b>

服务器可以表明记录可以被缓存多久，查找返回的DNS记录包含了一个存活时间（Time-to-live,TTL）值。尽管操作系统缓存会考虑TTL值，但浏览器通常忽略该值，并设置它自己的时间限制。只要浏览器和web服务器通信着，并保持TCP连接打开的状态，就没理由进行DNS查找。

****

## 规则10——精简JavaScript

<b>精简</b>

> 精简是从代码中移除不必要的字符以减小其大小，进而改善加载时间的实践。精简后所有的注释以及不必要的空白字符都将被移除。

<b>混淆</b>

> 混淆是可以应用在源代码上法的另外一种优化方式，和精简一样它也会移除注释和空白，同时它还会改写代码，函数和变量的名字将被转换为更短的字符串。通常这样做是为了增加对代码进行反向工程的难度。

<b><i>缺陷</i></b>

由于混淆更加复杂，混淆过程本身很有可能引入错误。

<b><i>维护</i></b>

混淆会改变javascript符号，因此需要对任何不能改变的符号进行标记，防止混淆其修改它们。

<b><i>调试</i></b>

经过混淆的代码很难阅读，这使得在产品环境中调试问题更加困难。

<b>锦上添花</b>

- 精简内联脚本
- 在压缩的基础上使用精简

****

## 规则11——避免重定向

<b>介绍</b>

重定向用于将用户从一个URL重新路由到另一个URL。重定向会使页面变慢。

重定向的类型如下，应该使用301,302，这样可以确保后退按钮能够正确工作。

- 301,302，在实际中都不会被缓存，除非有附加的头。
- html文档的头中包含的meta refresh标签可以在其content属性所指的秒数之后重定向用户。

        <meta http-equic="refresh" content="0; url=http://baidu.com" >

- javascript也可以重定向，将document.location设置为期望的URL即可。

<b>重定向之外的其他选择</b>

<b>缺少结尾的斜线</b>：缺少结尾的/会301重定向。

<b>连接网站</b>:重定向可以将旧网站连接到新的网站，但还可以其他形式将一个网站的不同部分连接起来，以及基于一些条件来引导用户。

<b>跟踪内部流量</b>:重定向经常用于跟踪用户流量的流向。通过分析来自www.yahoo.com的web服务器日志可以得到人们离开的首页后的流量去向。
也可以使用referer日志来跟踪流量去向，每个http请求都包含一个url，表明从哪个页面发起的请求，也就是引用方。使用referer日志避免了向用户发送重定向，也就改善了响应时间。

<b>美化url</b>:使用重定向的另一种动机是使url更加美观并且易于记忆，在前面的“缺少结尾的斜线”一节后，知道了结尾多了个“/”，不利于美观。关键是要找出一种方式，无需重定向就能拥有如此简洁的url，与其让用户忍受额外的http请求，最好还是使用“连接网站”一节中介绍的aLIas，mod_rewrite DIrectorySlash和直接连接代码来避免重定向。

****

## 删除重复脚本

<b>避免重复脚本</b>

- 在模板系统中实现一个脚本管理模块
- 实现一个删除过滤重复脚本的功能

*****

## 规则13——配置ETag

<b>介绍</b>

实体标签（Entity Tag,ETag,HTTP1.1）是web服务器和浏览器用于确认缓存组件有效性的一种机制。

浏览器在条件GET请求检测缓存的组件是否和原始服务器上的组件匹配时有两种方式：

- 比较最新的修改日期
- 比较实体标签

<b><i>最新修改时间</i></b>

原始服务器通过Last-Modified响应头来返回组件的最新修改日期。

<b><i>实体标签</i></b>

ETag是唯一标识了一个组件的一个特定版本的字符串，该字符串必须用引号引起来。
服务器返回ETag字段到浏览器，此后浏览器访问服务器会使用If-None_Match头将ETag传回原始服务器进行比较，如果匹配返回304状态码。

<b>ETag带来的问题</b>

当浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求时，ETag不会匹配，这对于使用服务器集群来处理请求的网站来说很常见。

ETag还降低了代理缓存的效率。代理后面用户缓存的ETag经常和代理缓存的ETag不匹配，这导致不必要的请求被发送到原始服务器。

If-None-Match比If-Modified-Since具有更高的优先级，只要使用了ETag,即使ETag不匹配也不会看Expires而返回304.

<b>ETag是否该用</b>

如果你的组件必须通过最新修改日期之外的一些东西来进行验证，则ETag是一种强大的方法。如果你无须自定义ETag的内容，最好简单地将其移除。

*****

## 规则14——使Ajax可缓存

<b>改善Ajax请求</b>

改善Ajax请求最重要的方式就是使响应可缓存，其他的规则也有一些适用于Ajax请求：

- 规则4，压缩组件
- 规则9，减少DNS查找
- 规则10，精简Javascript
- 规则11，避免重定向
- 规则13，ETag,用还是不用

